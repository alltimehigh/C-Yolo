================================================================================
CSharpYoloSimple 執行緒（Thread）架構說明
================================================================================

一、執行緒架構概述
================================================================================

本應用程式採用多執行緒架構，主要包含以下執行緒：

1. 主 UI 執行緒（Main UI Thread）
   - 處理所有用戶界面交互
   - 處理表單事件（按鈕點擊、視窗關閉等）
   - 負責所有 UI 控件的創建和初始化

2. 時間更新執行緒（Time Update Thread）
   - 獨立執行緒：timeThread
   - 功能：每秒更新一次時間顯示
   - 更新頻率：1000ms（1秒）

3. UI 更新執行緒（UI Update Thread）
   - 獨立執行緒：uiUpdateThread
   - 功能：定期檢查並更新 UI 控件
   - 更新頻率：50ms（約 20 FPS）

4. 圖片載入執行緒（Image Load Thread）
   - 臨時執行緒：imageLoadThread
   - 功能：在後台載入和處理圖片
   - 生命週期：處理完成後自動結束


二、執行緒變數定義
================================================================================

位置：Form1.cs 第 22-34 行

private Thread timeThread;           // 時間更新執行緒
private bool isRunning = true;       // 控制執行緒運行的標誌
private Thread uiUpdateThread;       // UI 更新執行緒
private string currentTime = "";     // 時間數據（共享變數）
private string imagePath = "";       // 圖片路徑數據（共享變數）
private Image currentImage = null;   // 圖片數據（共享變數）
private bool uiNeedsUpdate = false;  // UI 需要更新的標誌（共享變數）
private object lockObj = new object(); // 同步鎖（用於保護共享數據）


三、執行緒啟動機制
================================================================================

3.1 時間更新執行緒啟動
位置：Form1.cs 第 563-569 行

private void StartTimeThread()
{
    isRunning = true;                                    // 設置運行標誌為 true
    timeThread = new Thread(new ThreadStart(UpdateTime)); // 創建新執行緒
    timeThread.IsBackground = true;                       // 設置為後台執行緒
    timeThread.Start();                                  // 啟動執行緒
}

說明：
- IsBackground = true：當主程式關閉時，執行緒會自動結束
- 執行緒方法：UpdateTime()，在獨立執行緒中運行

3.2 UI 更新執行緒啟動
位置：Form1.cs 第 570-576 行

private void StartUIUpdateThread()
{
    uiUpdateThread = new Thread(new ThreadStart(UpdateUI)); // 創建新執行緒
    uiUpdateThread.IsBackground = true;                      // 設置為後台執行緒
    uiUpdateThread.Name = "UIUpdateThread";                  // 設置執行緒名稱（便於調試）
    uiUpdateThread.Start();                                  // 啟動執行緒
}

說明：
- 執行緒名稱有助於在調試時識別執行緒
- 執行緒方法：UpdateUI()，在獨立執行緒中運行

3.3 圖片載入執行緒啟動
位置：Form1.cs 第 727-729 行（在 button1_Click 方法中）

Thread imageLoadThread = new Thread(() => LoadImageInBackground(selectedFilePath));
imageLoadThread.IsBackground = true;
imageLoadThread.Start();

說明：
- 使用 Lambda 表達式傳遞參數（文件路徑）
- 每次選擇圖片時創建新的執行緒
- 處理完成後執行緒自動結束


四、執行緒執行邏輯
================================================================================

4.1 時間更新執行緒邏輯
位置：Form1.cs 第 578-613 行

private void UpdateTime()
{
    while (isRunning)  // 持續運行直到 isRunning 為 false
    {
        try
        {
            // 1. 獲取當前時間
            string currentTime = DateTime.Now.ToString("HH:mm:ss");

            // 2. 線程安全地更新 UI
            if (labelTime.InvokeRequired)  // 檢查是否需要在主執行緒執行
            {
                // 使用 BeginInvoke 異步更新（不阻塞當前執行緒）
                labelTime.BeginInvoke(new Action(() =>
                {
                    labelTime.Text = currentTime;
                }));
            }
            else
            {
                // 如果已經在主執行緒，直接更新
                labelTime.Text = currentTime;
            }

            // 3. 等待 1 秒後再次更新
            Thread.Sleep(1000);
        }
        catch (ThreadAbortException)
        {
            // 執行緒被終止時退出循環
            break;
        }
        catch (Exception)
        {
            // 忽略其他異常，繼續運行
        }
    }
}

關鍵點：
- InvokeRequired：檢查當前執行緒是否為主 UI 執行緒
- BeginInvoke：異步調用，不會阻塞當前執行緒
- Thread.Sleep(1000)：每秒更新一次
- 異常處理：捕獲 ThreadAbortException 以優雅退出

4.2 UI 更新執行緒邏輯
位置：Form1.cs 第 614-663 行

private void UpdateUI()
{
    while (isRunning)  // 持續運行直到 isRunning 為 false
    {
        try
        {
            bool needsUpdate = false;
            string timeToDisplay = "";
            string pathToDisplay = "";
            Image imageToDisplay = null;

            // 1. 使用鎖保護共享數據的讀取
            lock (lockObj)
            {
                if (uiNeedsUpdate)  // 檢查是否需要更新
                {
                    needsUpdate = true;
                    // 複製共享數據到局部變數（避免長時間持有鎖）
                    timeToDisplay = currentTime;
                    pathToDisplay = imagePath;
                    imageToDisplay = currentImage;
                    uiNeedsUpdate = false;  // 重置標誌
                }
            }

            // 2. 如果需要更新，在主執行緒上執行 UI 更新
            if (needsUpdate)
            {
                if (this.InvokeRequired)
                {
                    // 使用 Invoke 同步調用（確保更新完成）
                    this.Invoke(new Action(() =>
                    {
                        UpdateUIControls(timeToDisplay, pathToDisplay, imageToDisplay, check);
                    }));
                }
                else
                {
                    UpdateUIControls(timeToDisplay, pathToDisplay, imageToDisplay, check);
                }
            }

            // 3. 降低更新頻率，減少 CPU 占用
            Thread.Sleep(50);  // 約 20 FPS 的更新頻率
        }
        catch (Exception)
        {
            // 忽略異常，繼續運行
        }
    }
}

關鍵點：
- lock (lockObj)：保護共享數據的讀寫，避免競態條件
- 快速釋放鎖：在鎖內只讀取數據，立即釋放鎖
- Invoke vs BeginInvoke：
  * Invoke：同步調用，等待執行完成
  * BeginInvoke：異步調用，不等待執行完成
- Thread.Sleep(50)：約 20 FPS，平衡響應性和 CPU 使用率

4.3 圖片載入執行緒邏輯
位置：Form1.cs 第 737-761 行

private void LoadImageInBackground(string filePath)
{
    try
    {
        // 1. 在後台執行緒載入圖片（避免阻塞 UI）
        Image loadedImage = Image.FromFile(filePath);
        
        // 2. 執行檢測處理（耗時操作）
        ProcessAndSaveImage(filePath);

        // 3. 使用鎖保護共享數據的寫入
        lock (lockObj)
        {
            imagePath = filePath;
            currentImage = loadedImage;
            uiNeedsUpdate = true;  // 標記需要更新 UI
        }
    }
    catch (Exception ex)
    {
        // 4. 錯誤處理：在主執行緒顯示錯誤訊息
        this.Invoke(new Action(() =>
        {
            MessageBox.Show($"加载失败：{ex.Message}");
        }));
    }
}

關鍵點：
- 耗時操作在後台執行：圖片載入和檢測處理不會阻塞 UI
- 鎖保護：確保共享數據的線程安全
- uiNeedsUpdate 標誌：通知 UI 更新執行緒進行更新
- 錯誤處理：使用 Invoke 在主執行緒顯示錯誤訊息


五、線程安全機制
================================================================================

5.1 同步鎖（lock）
用途：保護共享數據的讀寫操作

共享變數：
- currentTime
- imagePath
- currentImage
- uiNeedsUpdate
- check

使用方式：
lock (lockObj)
{
    // 讀取或寫入共享變數
    imagePath = filePath;
    currentImage = loadedImage;
    uiNeedsUpdate = true;
}

注意事項：
- 鎖的範圍應盡可能小，避免長時間持有鎖
- 在鎖內只進行必要的數據操作
- 不要在鎖內執行耗時操作

5.2 UI 更新機制
Windows Forms 規則：UI 控件只能在創建它們的執行緒（主 UI 執行緒）中訪問

解決方案：
1. InvokeRequired 檢查：
   if (control.InvokeRequired)
   {
       // 需要切換到主執行緒
   }

2. Invoke（同步）：
   control.Invoke(new Action(() => { /* UI 操作 */ }));
   - 等待執行完成
   - 適用於需要確保執行順序的操作

3. BeginInvoke（異步）：
   control.BeginInvoke(new Action(() => { /* UI 操作 */ }));
   - 不等待執行完成
   - 適用於不緊急的更新操作

5.3 執行緒生命週期管理
啟動：
- 在構造函數中啟動時間更新和 UI 更新執行緒
- 在按鈕點擊時創建圖片載入執行緒

停止：
位置：Form1.cs 第 766-777 行（OnFormClosing 方法）

protected override void OnFormClosing(FormClosingEventArgs e)
{
    base.OnFormClosing(e);
    
    // 1. 設置停止標誌
    isRunning = false;
    
    // 2. 等待執行緒結束（最多等待 1 秒）
    if (timeThread != null && timeThread.IsAlive)
    {
        timeThread.Join(1000);  // 等待執行緒結束，最多 1 秒
    }
    
    // 3. 清理資源
    if (pictureBox1.Image != null)
    {
        pictureBox1.Image.Dispose();
        pictureBox1.Image = null;
    }
}

說明：
- isRunning = false：通知所有執行緒停止運行
- Join(1000)：等待執行緒結束，超時時間 1 秒
- IsBackground = true：確保程式關閉時執行緒自動結束


六、執行緒間通信流程
================================================================================

6.1 圖片處理流程

用戶操作（主 UI 執行緒）
    ↓
button1_Click() - 選擇圖片
    ↓
創建 imageLoadThread（圖片載入執行緒）
    ↓
LoadImageInBackground() - 載入圖片
    ↓
ProcessAndSaveImage() - 處理圖片（耗時操作）
    ↓
lock (lockObj) - 更新共享數據
    ├─ imagePath = filePath
    ├─ currentImage = loadedImage
    └─ uiNeedsUpdate = true（通知需要更新）
    ↓
uiUpdateThread（UI 更新執行緒）檢測到 uiNeedsUpdate = true
    ↓
lock (lockObj) - 讀取共享數據
    ├─ 複製數據到局部變數
    └─ uiNeedsUpdate = false（重置標誌）
    ↓
this.Invoke() - 切換到主 UI 執行緒
    ↓
UpdateUIControls() - 更新 UI 控件
    ├─ 更新時間顯示
    ├─ 更新路徑顯示
    ├─ 更新圖片顯示
    └─ 更新狀態指示器

6.2 時間更新流程

timeThread（時間更新執行緒）
    ↓
UpdateTime() - 每秒執行一次
    ↓
獲取當前時間：DateTime.Now.ToString("HH:mm:ss")
    ↓
labelTime.BeginInvoke() - 異步更新 UI
    ↓
主 UI 執行緒更新 labelTime.Text


七、執行緒設計優點
================================================================================

1. 響應性
   - UI 不會因為圖片處理而凍結
   - 用戶可以繼續與界面交互

2. 性能
   - 多執行緒並行處理，充分利用 CPU
   - 後台執行耗時操作，不影響用戶體驗

3. 穩定性
   - 使用鎖保護共享數據，避免競態條件
   - 使用 Invoke/BeginInvoke 確保線程安全的 UI 更新
   - 後台執行緒設置，確保程式關閉時執行緒自動結束

4. 可維護性
   - 清晰的執行緒職責劃分
   - 統一的錯誤處理機制
   - 良好的代碼註釋（中英文並列）


八、注意事項與最佳實踐
================================================================================

1. 不要在鎖內執行耗時操作
   ❌ 錯誤示例：
   lock (lockObj)
   {
       ProcessImage();  // 耗時操作，會阻塞其他執行緒
   }
   
   ✅ 正確做法：
   Image result = ProcessImage();  // 在鎖外執行
   lock (lockObj)
   {
       currentImage = result;  // 只更新數據
   }

2. 使用局部變數減少鎖持有時間
   ✅ 正確做法：
   string path;
   lock (lockObj)
   {
       path = imagePath;  // 快速讀取
   }
   // 在鎖外使用 path

3. UI 更新必須在主執行緒執行
   ❌ 錯誤示例：
   labelTime.Text = "00:00:00";  // 在非主執行緒中直接更新
   
   ✅ 正確做法：
   if (labelTime.InvokeRequired)
   {
       labelTime.Invoke(new Action(() => {
           labelTime.Text = "00:00:00";
       }));
   }

4. 執行緒停止時要優雅退出
   - 使用 isRunning 標誌控制循環
   - 在 OnFormClosing 中設置 isRunning = false
   - 使用 Join() 等待執行緒結束（設置超時時間）

5. 異常處理
   - 在執行緒方法中使用 try-catch
   - 捕獲 ThreadAbortException 以優雅退出
   - 其他異常應記錄或顯示給用戶


九、執行緒狀態圖
================================================================================

主 UI 執行緒
    │
    ├─ 啟動應用程式
    │  ├─ StartTimeThread() ──→ timeThread
    │  └─ StartUIUpdateThread() ──→ uiUpdateThread
    │
    ├─ 用戶點擊按鈕
    │  └─ button1_Click()
    │     └─ 創建 imageLoadThread
    │
    └─ 關閉應用程式
       └─ OnFormClosing()
          ├─ isRunning = false
          └─ timeThread.Join(1000)

timeThread（時間更新執行緒）
    │
    └─ UpdateTime()
       ├─ 獲取當前時間
       ├─ labelTime.BeginInvoke() ──→ 主 UI 執行緒更新
       └─ Thread.Sleep(1000)
       └─ 循環（直到 isRunning = false）

uiUpdateThread（UI 更新執行緒）
    │
    └─ UpdateUI()
       ├─ lock (lockObj) 檢查 uiNeedsUpdate
       ├─ 讀取共享數據
       ├─ this.Invoke() ──→ 主 UI 執行緒更新
       └─ Thread.Sleep(50)
       └─ 循環（直到 isRunning = false）

imageLoadThread（圖片載入執行緒）
    │
    └─ LoadImageInBackground()
       ├─ Image.FromFile() - 載入圖片
       ├─ ProcessAndSaveImage() - 處理圖片
       ├─ lock (lockObj) 更新共享數據
       │  ├─ imagePath = filePath
       │  ├─ currentImage = loadedImage
       │  └─ uiNeedsUpdate = true
       └─ 執行緒結束


十、總結
================================================================================

本應用程式採用多執行緒架構，實現了：
- 響應式 UI：不會因為後台處理而凍結
- 實時更新：時間顯示和狀態指示器實時更新
- 線程安全：使用鎖和 Invoke 機制確保數據安全
- 資源管理：後台執行緒設置，自動清理資源

執行緒分工明確：
- 主 UI 執行緒：處理用戶交互
- 時間更新執行緒：定期更新時間顯示
- UI 更新執行緒：定期檢查並更新 UI
- 圖片載入執行緒：後台處理圖片，避免阻塞 UI

這種設計確保了應用程式的流暢運行和良好的用戶體驗。

================================================================================
文件生成時間：2024
================================================================================
